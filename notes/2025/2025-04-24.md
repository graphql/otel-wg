# GraphQL OTel WG Notes - April 2025

**Watch the replays:**
[GraphQL OTel Working Group Meetings on YouTube](https://www.youtube.com/playlist?list=PLP1igyLx8foFO2xFpWp7IturLnInoyWv1)

Agenda:
[https://github.com/graphql/otel-wg/blob/main/agendas/2025/04-Apr/24-otel-wg-april-2025.md](https://github.com/graphql/otel-wg/blob/main/agendas/2025/04-Apr/24-otel-wg-april-2025.md)

## Introduction of attendees their motivation & goals (10m, Host)

- Pascal: Want to make a standard that everyone can follow so it can be consumed
  by all types of tooling.
- Benjie: Want to ensure we're not over-recording so we don't shoot ourselves in
  the foot by e.g. recording every resolver call.
- Trask: OpenTelemetry community can't do all libraries so we want
  libraries/specs to be empowered to do that work themselves. Want to help you
  be successful and be a model for future efforts.
- Bryn: third party APMs, hard to get started due to lack of OTel standard for
  GraphQL. GraphQL Document is rather heavy to send!

## Determine volunteers for note taking (1m, Host)

- Benjie

## Review agenda (2m, Host)

- Review what's out there.
- Define what we want to achieve - what insights do users need?
- How do we get there?

## Introduction and current state of OpenTelemetry in GraphQL (5m, Pascal)

- Current graphql registry in OTel website lists operation type / operation name
  / document are the only standard attributes right now
  - And sending the document for every operation is not ideal - they can get
    large! Waste of bandwidth/storage.
- [https://github.com/open-telemetry/semantic-conventions/pull/562](https://github.com/open-telemetry/semantic-conventions/pull/562)
  specifies traces, but would be nice to add meters/counters too.

## Identify and collect core use cases we want to support (10m, Pascal)

- Focus on what we want to discover or enable through OTEL data
- Versioning: which client versions are in use.
- How long to validate, coerce, compile, plan, execute the operation? Cache hit
  / cache miss?
- Bryn: must work nicely with the rest of the OTel specs - e.g. can we get any
  of this from HTTP semantic conventions?
- How does cardinality come into this? Field-level metrics will have a high
  cardinality.
- Pascal: GraphQL.js OTel wrapping of resolvers makes sync execution suddenly
  really expensive
- Pascal: HotChocolate only traces asynchronous resolvers, no need for sync
- Chillicream have a meter that counts how many times a field was requested.
  Attribute differentiates the field requested. Static allocation of
  meter/counter, increment it by one when a request comes in - 50 counters for
  50 fields.
- More pressure on API doesn't produce more metrics, helps avoid memory
  increases.
- Trask: default cap in OTel is 2000 combinations (it is adjustable).
- Bryn: combination of field against type is the unique identifier ("schema
  coordinates") - you may end up with 10k of these.
- Costs in DataDog/etc are usually based on cardinality.
- HTTP has route which has placeholders for ID/etc - so you'd have similar
  issues with a REST API.
- Route is recommended, e.g. generated by SpringBoot controller paths.
- Benjie: if we ruled out scalar fields, there'd be a lot less cardinality
- Bryn: Operation name and query type belong in there.
- Benjie: hash of the document (e.g. persisted query/trusted document ID)
- Trask: User_Agent.original is enabled by default (not under HTTP.)
- Pascal: version of the schema
- Benjie: recommend this is an arbitrary string
- Pascal: probably a resource attribute rather than a regular one
- Valentin: hot loading of the schema
- Pascal: for gateway a combination of a hash of the schema and the version of
  the server would work
- Trask (chat): `service.version`
- Trask: you can define resource conventions alongside the semantic conventions
- Trask: is it immutable and singleton?
- immutable: cannot change during the runtime of the service currently; but
  "entities" work is addressing these issues around immutability and
  organization. Defines descriptive attributes that can or cannot change.
- Pascal: `service.version` is likely the deployed Docker version or git
  version, but for federation the schema may change at runtime so since resource
  attributes are immutable we'll need a span attribute
- Valentin (chat): It can happen in rare cases that some spans with 2 different
  schema id are interleaved
- Bryn: errors are key. HTTP allows for HTTP status.
- Trask: `error.type` and `error.message` may be appropriate
- Could have a GraphQL-specific error map
- Span events are being transitioned to log-based events.
- Each error could be recorded as an event.
- Span events are being deprecated.

# Use Cases
## Attributes of traces
- operatrion name
- operation type
- operation hash
- client type/name/version -> user_agent.orginal 
- schema id/version <- user configurable *optional*
- span.status

## Errors
error.type
error.message
- schema coordinate
- path

## Performance Insights
- How does an operation performe over time
- How does a resolver perform over time
- Which operations/fields/resolver have errors
- How big are dataloader batches
- How many operations are executed/executing -> subscription
- Which client & version sent a request? What is there distribution?
- How long does an operation take to validate, coerce (& compile)

## Error Insights
- What are the most common errors

## Schema Evolution Questions
- Is this field in use?
- How often is a field requested?
- How many requests are made including a field?

## Distributed GraphQL
- Query Plan Step?
- Query Planning Duration?

