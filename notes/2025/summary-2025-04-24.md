# Meeting Summary for OTel WG

**NOTICE**: This summary was auto-generated by Zoom's "AI". AI-generated
content may be inaccurate or misleading. Always check for accuracy. If in
doubt, please consult the meeting recording at
https://youtube.com/@GraphQLFoundation/playlists

- Meeting start: 2025-04-24T16:59:26Z
- Meeting end: 2025-04-24T18:03:22Z
- Summary start: 2025-04-24T16:59:54Z
- Summary end: 2025-04-24T18:02:36Z

The group discussed the need for standardized OpenTelemetry conventions for GraphQL, focusing on defining useful traces and metrics without including overly large payloads. They explored challenges related to managing large amounts of data in APIs and GraphQL, as well as handling GraphQL errors in OpenTelemetry spans. The group agreed to meet monthly and use the OpenTelemetry working group repository for follow-up discussions and issues.

## Next Steps

- Trask to write up different options for handling GraphQL errors in spans and follow up with the group.
- All participants to research and write up topics discussed in the meeting asynchronously before the next meeting.
- Pascal to create a new agenda entry for the next monthly meeting.
- All participants to add topics to the new agenda for the next meeting.
- All participants to open and follow issues in the Otel Wg repository for further discussion.

## Summary

### Standardizing OpenTelemetry for GraphQL Conventions

The group discusses the goals and motivations for creating standardized OpenTelemetry conventions for GraphQL. Pascal from Chili Piper emphasizes the need for common spans, tags, and meters across different GraphQL implementations to enable plug-and-play functionality with various monitoring tools. Benjie aims to ensure the conventions are sensible and don't introduce performance issues. Trask from OpenTelemetry offers support to help make this effort successful. Bryn from Apollo highlights the challenges of connecting to third-party APMs without standardized conventions. The group agrees on the importance of defining useful traces and metrics that don't include overly large payloads like full GraphQL documents.

### Monitoring Operations and Resolver Performance

Pascal discussed the need for a tool to monitor the performance of operations and resolvers over time, including error tracking and data loader performance. He also mentioned the importance of understanding client and versioning semantics. Bryn raised concerns about the high cardinality of field-level metrics and their potential impact on API performance. Pascal explained their approach to tracing asynchronous resolvers and field requests, but acknowledged the need to consider the upper boundary of meter dimensions. Trask suggested that the default limit in open telemetry SDKs is 2,000 combinations.

### API Data Management Challenges Discussed

Pascal and Bryn discussed the challenges of managing large amounts of data, particularly in the context of APIs and GraphQL. Pascal suggested that the issue might be similar for both REST and GraphQL APIs. Benjie proposed a potential solution, suggesting that the expense of loading object records and lists of object records could be reduced. Bryn proposed starting with easier tasks, such as moving documents from recommended to optional, and suggested that this could be a less controversial approach.

### Version Tracking in Client-Server Interactions

In the meeting, Benjie and Pascal discussed the importance of identifying and tracking different versions of a document, particularly in the context of client and server interactions. They agreed that a unique identifier, such as a SHA hash, could be used to distinguish between versions. Pascal suggested that this information could be correlated with user agent data to identify specific client versions. However, they also acknowledged that this might not be necessary for all systems, especially those with hot reloading capabilities. The team also discussed the potential for proxying GraphQL to multiple places and the need for version tracking in gateway scenarios. Valentin proposed using a version attribute that could be represented in different ways, such as a hash or a specific ID, depending on the system being used.

### Schema Hash for Interoperability Discussion

Bryn, Valentin, Pascal, Trask, and Benjie discussed the use of schema hash and its potential for interoperability. Pascal suggested defining resource attributes in the semantic convention, which could include an optional schema ID. Trask agreed but noted that some edge cases might require further consideration. Pascal also raised the issue of schema changes during runtime in federated scenarios, which could affect the service version. Trask suggested starting with a span attribute and potentially moving it to an entity attribute as the entities work develops. The team agreed to pick one approach for now.

### GraphQL Error Handling in OpenTelemetry

The group discusses how to handle GraphQL errors in OpenTelemetry spans. They explore options for reporting errors, including using span attributes, events, and logs. Trask agrees to write up different options for handling errors. The group also discusses the importance of capturing schema coordinates and operation paths for GraphQL errors. They decide to meet monthly and use the OpenTelemetry working group repository for follow-up issues and discussions.
