# Meeting Summary for OTel WG

**NOTICE**: This summary was auto-generated by Zoom's "AI". AI-generated
content may be inaccurate or misleading. Always check for accuracy. If in
doubt, please consult the meeting recording at
https://youtube.com/@GraphQLFoundation/playlists

- Meeting start: 2025-08-28T17:00:14Z
- Meeting end: 2025-08-28T18:11:25Z
- Summary start: 2025-08-28T17:01:14Z
- Summary end: 2025-08-28T18:07:07Z

The meeting focused on discussing observability and tracing specifications for GraphQL applications, with the team exploring various technical aspects including error handling, operation IDs, and data loader behavior. The team worked on refining terminology and naming conventions for spans, attributes, and operations, while also addressing concerns about security and cardinality in persisted queries. Updates were shared on ongoing pull requests and future workgroup meetings, with plans to discuss GraphQL errors and distributed graphical work in upcoming sessions.

## Next Steps

- Pascal: Reach out to Trask via email about handling GraphQL errors and the new logging format in OpenTelemetry.
- Pascal: Work with the team on updating the specification for the new format that uses logging instead of events on traces in OpenTelemetry.
- Pascal: Verify with Benjie and Michael the correct terminology from the GraphQL spec regarding "request" vs "operation" terminology.
- Pascal: Rephrase the documentation about operation domains with bounded cardinality to emphasize that persisted operations are recommended for public APIs and clarify security implications.
- Pascal: Update the specification to explicitly mention trusted documents/persisted operations and clarify that automatic persisted queries don't provide the same security benefits.
- Pascal: Review the naming of "GraphQL operation ID" versus potentially renaming it to better reflect its relationship with persisted operations.
- Pascal: Keep the pull requests open for further discussion on terminology.
- Pascal: Review and potentially remove the GraphQL operation name attribute from the parsing span.
- Marco: Clarify his comment about "request" terminology in the pull request.
- Team: Finalize the format options for GraphQL selection path representation.

## Summary

### GraphQL Observability Collaboration Discussion

The meeting began with introductions, where Brian explained his role in the Spring Team, focusing on Spring for GraphQL, and his interest in collaborating on observability instrumentation for Java-based GraphQL applications. Marco introduced himself as working on Datadog, emphasizing his interest in contributing to OTel semantics. Pascal outlined the agenda and mentioned that the current work on observability for GraphQL would be discussed further, with a focus on error handling. Pascal also noted plans to reach out to Trask for additional insights on error handling conventions.

### GraphQL Tracing Specifications Review

The team discussed GraphQL tracing specifications and PR reviews, focusing on attributes and formats. They agreed to use JSON path for selection paths due to its advantages for querying in telemetry systems and familiarity in testing contexts. Pascal explained that persisted operations are primarily a security feature, hashing queries in development to secure production environments. The team also confirmed that the GraphQL operation ID field should be named simply "ID" as per the HTTP specification.

### GraphQL Operations Terminology Clarification

The team discussed terminology around GraphQL operations, with Pascal explaining that while "server" might be questionable, "client" makes more sense for operations that don't necessarily run on servers. Marco clarified that in the GraphQL specification, "request" refers to the entire process including type checking, while "operation" refers to execution. The team also discussed persisted queries, with Pascal warning that automated persisted queries don't provide security benefits and should be avoided, while Brian emphasized that API owners need to maintain control over query cardinality regardless of whether they use persisted queries.

### Refining Trusted Document Language

Pascal, Brian, and Marco discussed refining the language around trusted documents and persisted operations, emphasizing the need for explicit phrasing and clarity, especially regarding bounded cardinality and automatic persisted queries. Pascal explained the addition of attributes to spans for better observability, highlighting their utility for querying spans based on attribute values. They also discussed harmonizing telemetry data across different backends and agreed on the necessity of certain attributes like operation names and IDs for unique identification. Marco raised a point about the correctness of using graphical operation names during parsing, which Pascal confirmed was acceptable due to attribute cardinality considerations.

### GraphQL Document ID Terminology Clarification

The team discussed the terminology and usage of document IDs in GraphQL operations, particularly focusing on the distinction between the ID of a persisted document and the ID passed in a POST request. Brian and Pascal clarified that while the latter is often referred to as the "operation ID," there might be confusion due to the generic use of "ID" across specifications. Pascal suggested the need to verify the correct terminology and potentially rename attributes for clarity, while Brian found a relevant RFC that could help resolve the confusion. The team agreed to further research the correct naming conventions and ensure alignment in their documentation.

### Span Naming Conventions for Tracing

Pascal and the team discussed the structure and naming conventions for spans in their tracing system. They agreed to use low cardinality tags for span names, such as "graph call data loader batch" and "data loader name," to facilitate easy discovery of executed operations. Pascal suggested adding batch size information to spans for monitoring purposes, though Rob raised concerns about potential cardinality issues with unique values. The team decided to address metrics and histogram representations in a future phase, as logs are not effective for GraphQL tracing.

### GraphQL Data Loader Behavior Discussion

Eli and Pascal discussed the behavior of data loaders in GraphQL, focusing on batch sizes and caching mechanisms. They clarified that the data loader batch size refers to the number of IDs passed to a database query, not the number of concurrent requests. Pascal explained that data loaders cache results for a single request to avoid N+1 queries and ensure consistent data across a resolver tree. Marco inquired about caching across requests, and Pascal confirmed that while data loaders can serve cached values within a request, serving cached values across requests is a different pattern not typically implemented with data loaders.

### Graphical Work Updates and Planning

Pascal presented updates on a pull request for distributed graphical work, which includes two spans: graphical server operation planning and operation step execution. He explained that these concepts could be useful beyond federation, potentially benefiting projects like GraphFast. Brian agreed to discuss the ideas with the GraphQL Java team. The group also discussed upcoming workgroup meetings, with Pascal mentioning a talk about their workgroup's goals in two weeks. Eli expressed interest in discussing GraphQL errors at the next meeting, and Pascal agreed to follow up with Trask about potential input on this topic.
