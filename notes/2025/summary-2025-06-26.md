# Meeting Summary for OTel WG

**NOTICE**: This summary was auto-generated by Zoom's "AI". AI-generated
content may be inaccurate or misleading. Always check for accuracy. If in
doubt, please consult the meeting recording at
https://youtube.com/@GraphQLFoundation/playlists

- Meeting start: 2025-06-26T17:00:26Z
- Meeting end: 2025-06-26T18:06:08Z
- Summary start: 2025-06-26T17:01:56Z
- Summary end: 2025-06-26T18:03:50Z

The meeting focused on discussing GraphQL tracing and semantic conventions, with participants reviewing specifications and guidelines while working on an Excel document from a previous session. The team explored various aspects of span implementation, including error handling, document validation tracking, and resolver tracing, while considering performance implications and best practices for different use cases. The discussion concluded with agreement to continue work on span definitions and resolver tracing configurations, with participants encouraged to think about desired metadata and potential span names for future meetings.

## Next Steps

- All attendees to think about what metadata should be added to a resolver trace and what the span name of a resolver trace should be.
- Pascal to add more description and examples to the document regarding the discussed span types (validation, parsing, variable coercion).
- Pascal to continue the discussion on resolver tracing and how to solve related challenges in the next meeting.
- Trask to follow up on the progress of the errors and exceptions discussion in the Open Telemetry specification, planned for July.
- All attendees to consider the use case of having more than just an operation span in GraphQL tracing.
- Pascal to sync with Benjie regarding the logical placement of validation and variable coercion spans in relation to the operation execution span.
- All attendees to consider the potential value of adding a data loader trace to the Open Telemetry semantic conventions for GraphQL.

## Summary

### GraphQL Community Meeting: Guidelines Review

The meeting began with introductions from Pascal, Rob, Eli, and Trask, who are members of a community focused on GraphQL and open-source contributions. Pascal noted that only half of the expected attendees had signed up and mentioned that the meeting would be recorded and published on YouTube. The group discussed the agenda, which included reviewing the spec membership agreement, participation guidelines, and contribution guidelines, as well as a code of conduct. The main focus of the meeting was to continue work on an Excel document started in a previous session, with Rob joining for the first time.

### Semantic Span Attributes Discussion

Pascal and Valentin discussed defining span attributes and their cardinality for semantic conventions, focusing on four previously defined attributes and considering additional spans like the operation span. Trask mentioned progress on supporting complex attributes for spans, which would enable capturing multiple errors as a list, and indicated that the broader discussion on errors and exceptions would resume in July. Pascal suggested postponing the error discussion once more to align with the updated timeline.

### JSON Encoding and Telemetry Handling

The team discussed encoding JSON objects with key-value pairs and lists, and explored the possibility of reusing the official error handling method by adding a new attribute. They debated the inclusion of metadata in operation spans for mutations, queries, and subscriptions, with a focus on lifecycle events like lexing, parsing, and stack validation. Pascal raised questions about how to handle caching and document parsing in telemetry, noting that some implementations compile object structures once and reuse them. Trask was asked about prior art in other implementations, and the team considered whether OpenTelemetry semantic conventions addressed similar use cases.

### GraphQL Document Validation Tracking

The team discussed the implementation of document validation tracking in GraphQL, focusing on whether to use spans or metrics. Pascal and Eli agreed that while validation only occurs once per document, tracking it could provide valuable insights for tooling and analysis. Trask suggested exploring the possibility of using attributes on spans to record validation times, while Pascal noted concerns about cardinality explosion with metrics. The discussion concluded with Trask offering to consult the Semantic Convention group about potential alternatives to nested spans for this use case.

### OpenTelemetry GraphQL Span Implementation

The team discussed the implementation of spans in OpenTelemetry for GraphQL operations. Pascal and Eli debated the logical sequence of spans, with Eli suggesting that the operation span should wrap all GraphQL-related activities to maintain semantic clarity. Rob warned about the challenge of adding metadata to operation spans before document parsing. Pascal agreed to provide examples to illustrate the differences in span implementation approaches.

### GraphQL Span Implementation Discussion

The team discussed the value and implementation of different spans in GraphQL tracing, focusing on operation execution, validation, and resolver tracing. They agreed that separate spans for validation and execution could be valuable for tooling, error correlation, and understanding execution patterns, though the level of detail should remain optional to accommodate different use cases. Pascal proposed adding parsing as a separate span due to its distinct characteristics from validation, while noting that some implementation-specific spans like context building and authentication might not be universally applicable. The team decided to continue the discussion in the next work group meeting to finalize the span definitions and ensure they capture all relevant GraphQL execution phases.

### GraphQL Resolver Tracing Best Practices

The group discussed resolver tracing in GraphQL servers, with Pascal warning about the performance impact of tracing all fields and emphasizing the need for careful configuration. Eli shared that PayPal traces only the first 2 levels of important resolvers, while Rob explained Shopify's use of OpenTelemetry Ruby with sampled verbosity, noting they may be tracing too much. The discussion concluded with agreement that data loaders should be addressed after resolving resolver tracing, and Pascal emphasized the importance of proper span naming and the need to make resolver tracing opt-in by default.

### Challenges in Nested Object Tracing

The team discussed the challenges of tracing nested objects and fields in graphical requests, where Trask explained that most semantic conventions focus on network calls rather than internal spans. Trask clarified that while Java instrumentation allows for method-level tracing, they typically disable internal spans by default to avoid noise, offering them as an opt-in feature. Pascal inquired about profiling capabilities, and Trask described OpenTelemetry's sample-based profiling, which correlates profiling data with traces, though he expressed skepticism about the value of capturing 150 nested spans in production.

### GraphQL Tracing Challenges Discussion

The group discussed challenges with GraphQL resolver tracing and distributed tracing in server environments. Pascal emphasized the need for a GraphQL server resolver trace with specific attributes, while Rob and Eli highlighted the trade-offs between granular tracing and performance, suggesting that tracing should focus on major data fetching operations rather than every resolver call. The team agreed to continue the discussion at the next meeting, with participants encouraged to think about desired metadata for resolver traces and potential span names. Valentin noted that resolver tracing might not be relevant for distributed federated gateways, but distributed tracing for subrequests remains valuable.
